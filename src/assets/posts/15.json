{"author":"PHSix","id":15,"title":"关于进程、线程、协程和多线程、异步","created_at":"2021-08-20T01:52:14Z","body":["最近学习rust的时候，在学习async，await语法的时候遇到了一些问题，因为rust在异步编程和async-std两本手册里面都对自己的零成本抽象很自信，而且也是rust经常拿在嘴边说的一个点，然而在我学习的时候发现对于异步是怎么实现的，异步实现的底层原理这种是我以前在使用javascript的时候完全没有考虑过和思考过的问题\r\n\r\n关于线程，进程，异步是我近期比较重点在思考的问题，近期主要思考的问题有以下几点：\r\n1. 在io密集型的场景下，多线程为什么性能不如异步？\r\n2. 异步的几种实现模型都有什么不同？\r\n3. 协程是如何抽象出来的？\r\n4. 像Go的goroutime和lua的coroutime又有什么区别？\r\n5. 用户态线程为什么会比内核态的快？\r\n6. 无论用户态还是内核态的线程到底是并行还是时间，又或是抢占式的？\r\n\r\n## 关于并行和并发\r\n**并行是指在同一时间多个线程（或多个进程）一起执行，没有需要谁等待谁的情况**\r\n\r\n**并发是线程（或进程）无法在同一时间一起执行，只能通过时间片轮询的方式来实现人肉眼看到的多个程序在同时跑的情况**\r\n\r\n时间片轮询：时间片轮询最经典的模型就是，当你的cpu只有一个核心时，系统同时有多个进程同时执行，这个时候如果要让进程有看起来同步执行的现象，就要采取时间片轮询，让每一个就绪进程占用一小段时间，然后在一段时间后轮询到下一个进程进行执行","## 关于进程\r\n进程是操作系统资源分配的基本单位，一个进程至少包括一个线程\r\n\r\n运行中的进程有五个状态：\r\n1. 运行态\r\n2. 就绪态\r\n3. 阻塞态\r\n4. 就绪挂起态\r\n5. 阻塞挂起态\r\n\r\n在linux操作系统中，系统的所有进程往往不是同时并行执行的，操作系统会让一部分（一个或多个）的进程先执行一段时间，当进程对操作系统发出了系统调用并处于等待阻塞状态之后，操作系统会将此进程派发到阻塞队列，然后从就绪队列中再抓一个就绪进程来运行，等到该阻塞进程状态变为就绪态的时候，系统会将该进程调至就绪队列中\r\n\r\n在多核处理机中，进程和进程之间可以是并行的，因为单个进程可以是只调用了一个操作系统的线程，又由于cpu有多个核心，系统在这个时候会将多个进程同时调用，做到进程间并行的效果\r\n\r\n但是由于现在操作系统在同一时刻运行的进程是非常多的，远超cpu的核心数，所以操作系统需要借助**时间片轮询**的方式来实现爱你并发","## 关于线程\n\n线程是系统调度的**基本单位**，一个进程**至少**要包括一个线程\n\n线程一般分为两种，一种内核级的线程，另一种为用户级的线程\n\n一般多线程的几种线程模型：\n1. 一对一模型，一个内核级线程对应一个用户级线程\n2. 一对多模型，一个内核级线程对应多个用户级线程\n3. M对N模型，M和内核级线程对应N个用户级线程，注意这里的M是小于N的，因为一个内核级线程至少要对应一个用户级线程\n\n多线程对比于多进程的好处\n1. 操作系统为了防止恶意进程通过内存对其他进程进行修改或读取内存信息给每一个进程建立了一个单独的虚拟内存空间，防止进程间直接进行互相访问(当然在现在的操作系统中，不同进程间的进行信息传递有着很多种实现方式，例如rpc，但是这些方式相比较于直接操作内存而言，是更慢的)\n2. 操作系统的分段和分页机制使得不同进程间的数据在不同的页表上，而多线程的数据是在同一个页表上，在访问和修改数据是减少了内存的换入换出，从而提高了程序的性能\n3. 创建一个线程相比于创建一个进程而言，性能和内存上的消耗是更低的，因为多线程是共享一个进程的内存空间，而多进程是有多个进程的内存空间\n\n> 用户级线程是由线程库实现的，对于操作系统而言，内核是看不到用户级线程的具体情况的，因为这一部分和内核没有什么直接关系，也可以说用户级线程对于内核来说是透明的","## 异步和协程\r\n在前面说线程的时候有讲到用户级线程的概念，这个就是现在异步和协程的主要主要实现方式，利用用户级线程和系统提供的非阻塞io操作（如linux的epoll）\r\n"]}